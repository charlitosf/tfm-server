package crypt

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"fmt"
)

// GenerateECKeyPair generates a new pair of P-256 Elliptic Curve keys (private and public)
func GenerateECKeyPair() (*ecdsa.PrivateKey, *ecdsa.PublicKey, error) {
	privk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, nil, err
	}
	pubk := privk.PublicKey
	return privk, &pubk, nil
}

// MarshalECKeys serializes the given Elliptic Curve private/public key pair into the x509 standard format.
func MarshalECKeys(privk *ecdsa.PrivateKey, pubk *ecdsa.PublicKey) (priv []byte, pub []byte, err error) {
	priv, err = x509.MarshalECPrivateKey(privk)
	if err != nil {
		return
	}
	pub, err = x509.MarshalPKIXPublicKey(pubk)
	return
}

// SignEC produces a signature by signing the SHA-256 hash of the given message with the given private key.
// Mind that the size of the key must be 256-bit or greater.
//
// The signature can then be verified using VerifyECSignature.
func SignEC(msg string, key *ecdsa.PrivateKey) ([]byte, error) {
	hash := Hash256(msg)
	return ecdsa.SignASN1(rand.Reader, key, hash)
}

// VerifyECSignature checks whether the given signature was generated by signing the SHA-256 hash of the given message
// with the private key corresponding to the given public key.
func VerifyECSignature(msg string, sig []byte, key *ecdsa.PublicKey) bool {
	hash := Hash256(msg)
	return ecdsa.VerifyASN1(key, hash, sig)
}

// Decode64AndDecryptWithPrivRSAECKey decrypts the given data with the given RSA private key after decoding it in Base64.
// It assumes the data is an Elliptic Curve private key and returns it.
// Mind that the size of the data must be lower than the maximum size allowed by the RSA key.
func Decode64AndDecryptWithPrivRSAECKey(data string, privK *rsa.PrivateKey) (*ecdsa.PrivateKey, error) {
	decoded_data, err := Decode64(data)
	if err != nil {
		return nil, err
	}
	decrypted_data, err := DecryptWithRSAPrivateKey(decoded_data, privK)
	if err != nil {
		return nil, err
	}
	return x509.ParseECPrivateKey(decrypted_data)
}

// Decode a base64 encoded ECDSA public key into a public key object
func DecodeECPubKey(key string) (pubk *ecdsa.PublicKey, err error) {
	pk, err := Decode64(key)
	if err != nil {
		return
	}
	parsedPK, err := x509.ParsePKIXPublicKey(pk)
	if err != nil {
		return
	}
	pubk, ok := parsedPK.(*ecdsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("the public key is not an Elliptic Curve key")
	}
	return
}
